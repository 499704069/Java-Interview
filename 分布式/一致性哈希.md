比如：一个分布式存储系统，要将数据存储到具体的节点（服务器）上， 在服务器数量不发生改变的情况下，如果采用普通的hash再对服务器总数量取模的方法（如key%服务器总数量），如果期间有服务器宕机了或者需要增加服务器，问题就出来了。 同一个key经过hash之后，再与服务器总数量取模的结果跟之前的结果会不一样，这就导致了之前保存数据的丢失。因此，引入了一致性Hash（Consistent Hashing）分布算法

![](http://mycsdnblog.work/201919091619-e.png)

把数据用hash函数（如md5，sha1)，映射到一个圆环上，如上图所示，数据在存储时，先根据hash算法算出key的hash值，对应到这个环中的位置，如k1对应图中所示的位置同，然后沿着顺时针方向找到服务器节点B，然后把k1在存到B这个节点中。

如果B节点宕机了，则B上的数据就会落到C节点上，如下图所示：

![](http://mycsdnblog.work/201919091623-Q.png)

这样，只会影响C节点，对于其他节点A、D的数据不会造成影响。但是问题来了，这样会造成C节点负载过重的情况，因为C节点承担了B节点的数据，所以C节点容易宕机，这样造成了分布不均匀。

为了解决这个问题，引入了“虚拟节点“的概念：即想象空上环上有很多”虚拟节点“，一个真实的服务器节点对应多个虚拟节点，数据存储的时候沿着环的顺时针方向找到虚拟节点，就找到了对应的真实服务器节点。如下图：

![](http://mycsdnblog.work/201919091624-l.png)

图中的A1、A2、B1、B2、C1、C2、D1、D2都是虚拟节点，机器A负载存储A1、A2的数据，机器B负载存储B1、B2的数据，机器C负载存储C1、C2的数据。由于这些虚拟节点数量很多，均匀分布，因此不会造成“雪崩”现象。

