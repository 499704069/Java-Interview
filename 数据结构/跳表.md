# 一、基本概念

对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低。

![](http://mycsdnblog.work/201919122211-f.png)

假如我们对链表每两个结点提取一个结点到上一级，然后建立一个索引指向原始结点，如下图所示。

![](http://mycsdnblog.work/201919122211-q.png)

这时候，我们要查找某一个数据的时候，就可以先在索引里面查找出一个大的范围，然后再下降到原始链表中精确查找。

比如，我们要查找 16，我们发现 16 位于 13 和 17 之间，这时候，我们就从 13 的地方下降到原始链表，然后再往后查询。原来我们查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。

**加一层索引后，查找一个结点需要遍历的次数减少了，也就是查找效率提高了**。

那么我们再多加一级索引呢？效果会不会有更大提升？

![](http://mycsdnblog.work/201919122214-x.png)

这一次，我们只需要遍历 6 个结点了。

数据量不大的时候这种方法可能效率提高得还不是很明显，下面看一个包含 64 个结点的例子，这次我们建立了五级索引。

![](http://mycsdnblog.work/201919122215-E.png)

查找 62 的时候原来需要遍历 62 次，现在只需要 11 次即可。**针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显**。

# 二、查询分析

![](http://mycsdnblog.work/201919122220-x.png)

![](http://mycsdnblog.work/201919122221-Z.png)

![](http://mycsdnblog.work/201919122222-L.png)

![](http://mycsdnblog.work/201919122223-j.png)

实际上，在实际开发中，原始链表中存储的可能是很大的对象，**而索引结点只需要存储关键值和几个指针，其额外占用的空间可以被忽略掉**。

# 三、插入和删除

![](http://mycsdnblog.work/201919122224-i.png)

![](http://mycsdnblog.work/201919122225-2.png)

从链表中删除结点的时候，如果结点在索引中也有出现，那么我们除了要删除原始链表中的结点，还要删除索引中的。

当我们不停地往跳表中插入数据的时候，如果我们不更新索引，就有可能出现某两个结点之间数据非常多的情况。极端情况下，跳表还会退化为单链表。

![](http://mycsdnblog.work/201919122232-Y.png)

因此，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，**如果链表结点变多了，索引值就相应地增加一些**。

当我们往跳表中插入数据的时候，我们可以选择同时也将这个数据插入到部分索引层中。而插入到哪些索引层中，则由一个随机函数生成一个随机数字来决定。如果这个数字为 K，那我们就将数据插入到第一级到第 K 级索引中。

![](http://mycsdnblog.work/201919122233-A.png)

# 四、应用

 为什么 Redis 要用跳表来实现有序集合而不是红黑树？

Redis 中的有序集合支持的核心操作主要有以下几个：

- 插入一个数据
- 删除一个数据
- 查找一个数据
- **按照区间查找数据**
- 迭代输出有序序列

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度和跳表是一样的。

但是，**按照区间查找数据这个操作**，红黑树的效率没有跳表高。跳表**可以在 O(logn) 时间复杂度定位区间的起点，然后在原始链表中顺序向后查询就可以了**，这样非常高效。

此外，相比于红黑树，跳表还具有代码更容易实现、可读性好、不容易出错、更加灵活等优点，因此 **Redis 用跳表来实现有序集合。**