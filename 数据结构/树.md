# 一、二叉树的创建

```java
private  TreeNode create(int[] nums) {
    ArrayList<TreeNode> list = new ArrayList<>();
    for (int i = 0; i < nums.length; i++) {
        list.add(new TreeNode(nums[i]));
    }
    TreeNode root = list.get(0);
    for (int i = 0; i < list.size() / 2; i++) {
        list.get(i).left = list.get(2 * i + 1);
        list.get(i).right = list.get(2 * i + 2);
    }
    return root;
}
```

# 二、二叉树的遍历（DFS）

## 2.1递归版本

### 2.1.1 先序

```java
private void PreOrder(TreeNode root) {
    if (root == null){
        return;
    }
    System.out.println(root.val);
    if (root.left != null) {
        PreOrder(root.left);
    }
    if (root.right != null) {
        PreOrder(root.right);
    }
}
```

### 2.1.2 中序

```java
private void InOrder(TreeNode root) {
    if (root == null){
        return;
    }
    if (root.left != null) {
        InOrder(root.left);
    }
    System.out.println(root.val);
    if (root.right != null) {
        InOrder(root.right);
    }
}
```

### 2.1.3 后序

```java
private void PostOrder(TreeNode root) {
    if (root == null){
        return;
    }
    if (root.left != null) {
        PostOrder(root.left);
    }
    if (root.right != null) {
        PostOrder(root.right);
    }
    System.out.println(root.val);
}
```

时间复杂度：每个节点只遍历一次，所以时间复杂度为O(n)

空间复杂度：栈的深度为树的高度，最坏情况下为O(n)

## 2.2非递归版本

使用栈

### 2.2.1 先序

先将头节点压入栈中，然后从栈中弹出栈顶节点，将该节点的右孩子和左孩子分别入栈，一直重复，直到栈为空。

```Java
private void PreOrder(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
        TreeNode temp = stack.pop();
        System.out.println(temp.val);
        if (temp.right != null) {
            stack.push(temp.right);
        }
        if (temp.left != null) {
            stack.push(temp.left);
        }
    }
}
```

### 2.2.2 中序

先把根节点入栈，然后从根节点开始依次将左节点入栈，遇到空的时候说明已经来到的最左节点，弹出栈顶元素打印，然后将root指向该节点的右孩子。

```java
private void InOrder(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    while (!stack.isEmpty() || root != null){
        if (root != null){
            stack.push(root);
            root = root.left;
        }else {
            TreeNode temp = stack.pop();
            System.out.println(temp.val);
            root = temp.right;
        }

    }
}
```

### 2.2.3 后序

使用两个栈：

先将根节点放入栈1，然后将出栈的节点再放入栈2，再将出栈节点的左右孩子压入栈1，一直重复。最后直接遍历栈2即可。

```java
private void PostOrder2(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    Stack<TreeNode> stack2 = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
        TreeNode temp = stack.pop();
        stack2.push(temp);
        if (temp.left != null) {
            stack.push(temp.left);
        }
        if (temp.right != null) {
            stack.push(temp.right);
        }
    }
    while (!stack2.isEmpty()){
        System.out.println(stack2.pop().val);
    }
}
```

# 三、二叉树的遍历（BFS）

```java
private void Level(TreeNode root) {
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.addLast(root);
    while (!queue.isEmpty()){
        TreeNode temp = queue.pollFirst();
        System.out.println(temp.val);
        if (temp.left != null) {
            queue.addLast(temp.left);
        }
        if (temp.right !=  null) {
            queue.addLast(temp.right);
        }
    }
}
```

