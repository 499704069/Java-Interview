一、JVM内存模型

堆，方法区（静态变量，常量、类加载信息），虚拟机栈（局部变量），本地方法栈，堆又分为新生代和老年代，新生代中又分为eden区和survivor区。

二、新生代和老年代可以转换吗?

new一个对象直接进入eden区，对象年龄大于15就进入老年代；

动态对象年龄判断：当前survivor区中年龄相同的对象比例超过survivor区的一半，那么大于或等于这个年龄的对象就直接进入老年代

三、垃圾回收

首先判断对象是否还存活，通过可达性分析来判断。垃圾回收算法：标记清除、标记整理、复制算法

四、可达性分析

从GC Root开始开始向下搜索，走过的路径叫做引用链，当一个对象到GC Root不可达时，说明该对象是不可用的

- 方法区中类的静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中native方法引用的对象
- 虚拟机栈中引用的对象

五、引用的分类

强引用：只要一个对象的强引用存在，那么就不会回收这个对象

软引用：被软引用指向的对象不会被收集，即使没有被强引用指向，除非jvm的内存不足，回收后收到通知

弱引用：如果一个对象有弱引用指向它，那么在GC的时候就会被销毁，回收后收到通知

虚引用：和弱引用一样，回收前收到通知

六、垃圾收集器

serial：单线程，复制算法

parnew：多线程，复制算法

parallel scavengr：降低用户的等待时间

serial old：serial老年代版本，标记整理

parallel old：parallel scavengr老年代版本，标记整理

CMS：标记清除，新生代使用parnew，获取最短回收停顿时间

初始标记

并发标记

重新标记

并发清除

G1：标记整理，支持并发与并行收集，建立可预测的停顿时间模型

初始标记

并发标记

最终标记

筛选回收

七、类初始化机制

new

进行反射调用的时候

初始化子类的时候，如果父类没有初始化，先初始化父类

包含main方法的类

八、类加载器

启动类加载器、扩展类加载器、应用程序类加载器

双亲委派模型

九、Java导包的过程

相当于在本类中又新加了一个类

十、Java中的jar包

java中的jar文件 ,装的是 .class 文件。它是一种压缩,和zip兼容，被称为jar包。JDK提供的许多类，也是以jar包的形式提供的。

十一、内存分配策略

对象优先分配在eden区

大对象直接进入老年代

长期存活的对象进入老年代

动态对象年龄判断

空间担保分配

十二、Java编译过程

- 词法解析：将Java关键字排序，使得程序能有序运行。
- 语法解析：词法解析后的Token序列整合为一颗抽象的语法树。
- 语义解析：将抽象语法树扩展地更加完善。
- 字节码解析：将字节码解析成完整的类。

