# 一、什么是服务治理

当服务越来越多，容量的评估，小服务资源浪费等问题逐渐显露，此时需要增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。

# 二、什么是微服务

微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。

# 三、服务间调用

RPC：自定义数据格式，基于原生TCP通信，速度快

HTTP：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。

# 四、Spring Cloud

- Eureka：注册中心
- Zuul：服务网关
- Ribbon：负载均衡
- Feign：服务调用
- Hystix：熔断器

# 五、Eureka

Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。

同时，服务提供方与Eureka之间通过`“心跳”`机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。

这就实现了服务的自动注册、发现、状态监控。

- Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址
- 提供者：启动后向Eureka注册自己信息（地址，提供什么服务）
- 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新
- 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态

**eureka的高可用，eureka集群**



# 六、Ribbon负载均衡

CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得   。

# 七、Hystix

**所以，Ribbon的超时时间一定要小于Hystix的超时时间。**

我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。

#  八、Elasticsearch

## 8.1 索引

Elasticsearch最关键的就是提供强大的索引能力了，为了提高搜索的性能，难免会牺牲某些其他方面，比如插入/更新，否则其他数据库不用混了。往Elasticsearch里插入一条记录，其实就是直接PUT一个json的对象，这个对象有多个fields，比如name, sex, age, about, interests，那么在插入这些数据到Elasticsearch的同时，Elasticsearch还默默的为这些字段建立索引--**倒排索引**，因为Elasticsearch最核心功能是搜索。

## 8.2 Elasticsearch是如何做到快速索引的

Elasticsearch使用的倒排索引比关系型数据库的B+Tree索引（为了提高查询的效率，减少磁盘寻道次数，将多个值作为一个数组通过连续区间存放，一次寻道读取多个数据，同时也降低树的高度。）快。

## 8.3 什么是倒排索引

![](http://mycsdnblog.work/201919071943-b.png)

例子：

![](http://mycsdnblog.work/201919071943-7.png)

Elasticsearch建立的索引如下:

![](http://mycsdnblog.work/201919071944-t.png)

> **Posting List**

Elasticsearch分别为每个field都建立了一个倒排索引，Kate, John, 24, Female这些叫term，而[1,2]就是**Posting List**。Posting list就是一个int的数组，存储了所有符合某个term的文档id。

看到这里，不要认为就结束了，精彩的部分才刚开始...

通过posting list这种索引方式似乎可以很快进行查找，比如要找age=24的同学，爱回答问题的小明马上就举手回答：我知道，id是1，2的同学。但是，如果这里有上千万的记录呢？如果是想通过name来查找呢？

> **Term Dictionary**

Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是**Term Dictionary**。现在再看起来，似乎和传统数据库通过B-Tree的方式类似啊，为什么说比B+Tree的查询快呢？

> ##### **Term Index**
>

B+Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过内存查找term，不读磁盘，但是如果term太多，term dictionary也会很大，放内存不现实，于是有了**Term Index**，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理解term index是一颗树：

![](http://mycsdnblog.work/201919071946-N.png)

这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。

![](http://mycsdnblog.work/201919071948-n.png)

所以term index不需要存下所有的term，而仅仅是他们的一些前缀与Term Dictionary的block之间的映射关系，再结合FST(Finite State Transducers)的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘随机读的次数。

# 九、令牌过期怎么办

token超时刷新

对于登录的用户签发其对应的jwt，我们在jwt设置他的固定有效期时间，在有效期内用户携带jwt访问没问题，当过有效期后jwt失效，用户需要重新登录获取新的jwt。这个体验不太好，好的体验应该是：**活跃的用户应该在无感知的情况下在jwt失效后获取到新的jwt，携带这个新的jwt进行访问，而长时间不活跃的用户应该在jwt失效后需要进行重新的登录认证。**

**这里就涉及到了token的超时刷新问题，解决方案看图：**

![](http://mycsdnblog.work/201919192225-a.png)

- 延长`token`过期时间
- 活跃用户在`token`过期时，在用户无感知的情况下动态刷新`token`，做到一直在线状态
- 不活跃用户在`token`过期时，直接定向到登录页

# 十、如何保证消息队列的中消息按序消费

主要思路有两种：1、单线程消费来保证消息的顺序性；2、对消息进行编号，消费者处理时根据编号判断顺序。 

问题分析：

![](http://mycsdnblog.work/201919192249-H.png)

如图，data1 和 data2 是有顺序的，必须 data1 先执行，data2 后执行；这两个数据被不同的消费者消费到了，可能 data2 先执行，data1 后执行，这样原来的顺序就错乱了。

解决方案：

![](http://mycsdnblog.work/201919192250-4.png)

如图，在 MQ 里面创建多个 queue，同一规则的数据（对唯一标识进行 hash），有顺序的放入 MQ 的 queue 里面，消费者只取一个 queue 里面获取数据消费，这样执行的顺序是有序的。或者还是只有一个 queue 但是对应一个消费者，然后这个消费者内部用内存队列做排队，然后分发给底层不同的 worker 来处理。



# 十一、sms短信发送失败

# 十二、消息队列高可用

RabbitMQ是比较有代表性的，因为是基于主从做高可用性的，我们就以他为例子讲解第一种MQ的高可用性怎么实现。（不是分布式的）rabbitmq有三种模式：单机模式，普通集群模式，镜像集群模式

普通集群

意思就是在多台机器上启动多个RabbitMQ实例，每个机器启动一个。但是你创建的queue，只会放在一个RabbitMQ实例上，但是每个实例都同步queue的元数据。完了你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。

这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。

而且如果那个放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让RabbitMQ落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据。

所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性可言了，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个queue的读写操作。

镜像集群

这种模式，才是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。

这样的话，好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue。

那么怎么开启这个镜像集群模式呢？我这里简单说一下，避免面试时人家问你你不知道，其实很简单RabbitMQ有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候可以要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。

# 十三、jwt实现一个帐号只能同时在一个设备(端)登录的思路

jwt的规范目前只检测jwt的发布者,过期时间,签名等信息.大部分现成的库都是按照标准写的.但是标准没有要求jwt带入登录时间等信息,因此用户连续登录多次,后台返回的token在有效期内都能访问后台api.也就是用户可以在多个设备同时登录.

**有人会采用在登录时将jwt用redis等储存起来,在api的中间件检查时去查数据库中是否储存了这个token,设置过期时间.如果用户再次登录,那么将该token用新生成的token替代.**

我们也可以不新建一个表,因为我们多数应用的用户表中都会储存用户的最后登录时间,最后登录ip等信息,我们可以在登录时将这些信息一边储存到数据库中,一边注入到jwt中.然后在用户访问api时在中间件中从中间件取出这些信息,和用户表中的信息进行对比,如果不符合,就不允许用户访问api.

