时间片调度：把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业停止运行，把处理器分配给其它作业使用，等待下一轮再继续运行。

# 一、概述

## 1.1 基本特征

1. 并发

   **并发是指在一段时间内同时运行多个程序，并行指同一时刻能运行多个指令**

2. 共享

   资源可被多个并发进程共同使用

3. 虚拟

   虚拟技术把一个物理实体转换为多个逻辑实体。

   主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

   **多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。**

   **虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。**

4. 异步

## 1.2 基本功能

**进程管理**：进程控制、进程同步、进程通信、死锁处理、处理机调度等。

**内存管理**：内存分配、地址映射、内存保护与共享、虚拟内存等。

**文件管理**：文件存储空间的管理、目录管理、文件读写管理和保护等。

**设备管理**：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

# 二、进程管理

## 2.1 进程与线程

### 2.1.1 进程

**为什么要引入进程？**

**更好的描述和控制程序的并发执行，实现操作系统的并发性和共享性**

进程是资源分配的基本单位

进程控制块 (Process Control Block, PCB) 描述进程的**基本信息和运行状态**，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

PCB记载进程的相关信息，主要包括：

- [程序计数器](https://baike.baidu.com/item/程序计数器)：接着要运行的指令地址。
- 进程状态：可以是new、ready、running、waiting或 blocked等。
- [CPU](https://baike.baidu.com/item/CPU)[暂存器](https://baike.baidu.com/item/暂存器)：如[累加器](https://baike.baidu.com/item/累加器)、索引暂存器（Index register）、[堆栈指针](https://baike.baidu.com/item/堆栈指针)以及一般用途暂存器、状况代码等，主要用途在于中断时暂时存储数据，以便稍后继续利用；其数量及类因电脑架构有所差异。
- CPU排班法：优先级、排班队列等指针以及其他参数。
- [存储器](https://baike.baidu.com/item/存储器)管理：如标签页表等。
- 会计信息：如CPU与实际时间之使用数量、时限、账号、工作或进程号码。
- 输入输出状态：配置进程使用[I/O](https://baike.baidu.com/item/I%2FO)设备，如[磁带机](https://baike.baidu.com/item/磁带机)。

### 2.1.2 线程

线程是独立调度的基本单位

一个进程种可以有多个线程，共享进程资源

### 2.1.3 区别

- 拥有资源

线程不拥有资源，进程是分配资源的基本单位

- 调度

线程是独立调度的基本单位，进程内线程切换不会引起进程切换

- 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

- 通信

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 2.2 进程状态的切换

![](http://mycsdnblog.work/201919072041-4.png)

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

## 2.3 进程调度算法

批处理系统：

- 先来先服务
- 短作业优先
- 最短剩余时间优先

交互式系统：

- 时间片轮转
- 优先级调度
- 多级反馈队列

## 2.4 进程同步

临界区：对资源互斥访问的代码区域

同步：多个进程按一定顺序执行

互斥：多个进程同一时刻只有一个可以进入临界区

信号量：PV操作

## 2.5 进程通信

进程通信的方式：

1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。

   **进程的亲缘关系通常是指父子进程关系**。

2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

3. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

4. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。**共享内存是最快的 IPC（进程间通信） 方式**，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

6. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

7. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

- 管道：速度慢，容量有限
- 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
- 信号量：不能传递复杂消息，只能用来同步
- 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 2.5.1 管道

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程中使用。

## 2.6 线程通信

1.锁机制：包括互斥锁、条件变量、读写锁 
互斥锁提供了以排他方式防止数据结构被并发修改的方法。 
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 
条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

2.信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

3.信号机制(Signal)：类似进程间的信号处理 

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

# 三、死锁

## 3.1 必要条件

1.互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放 

2.请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。 

3.不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用 

4.循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。

## 3.2 死锁预防

1、破坏互斥条件

2、破坏占有和等待条件

3、破坏不可剥夺

4、破坏循环等待

# 四、内存管理

## 4.1 为什么要进行内存管理

- 内存空间的分配与回收
- 地址转换
- 内存空间的扩充
- 内存保护

## 4.2 虚拟内存

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，**也就是说一个程序不需要全部调入内存就可以运行**，**这使得有限的内存运行大程序成为可能**。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

## 4.3 分页系统地址映射

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。

![](http://mycsdnblog.work/201919162057-B.png)

## 4.4 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

### 4.1.1 最佳

所选择的被换出的页面将是**最长时间内不再被访问**，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

![](http://mycsdnblog.work/201919152233-h.png)

开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。

### 4.1.2 最近最久未使用

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。

为了实现 LRU，需要在内存中维护一个所有**页面的链表。** **当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。**

因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

![](http://mycsdnblog.work/201919152235-J.png)

### 4.1.3 最近未使用

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

### 4.1.4 先进先出

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

# 六、面试

## 6.1 一个二进制文件怎么执行