时间片调度：把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业停止运行，把处理器分配给其它作业使用，等待下一轮再继续运行。

# 一、概述

## 1.1 基本特征

1. 并发

   **在一段时间内同时运行多个程序，并行指同一时刻能运行多个指令**

2. 共享

   资源可被多个并发进程共同使用

3. 虚拟

4. 异步

## 1.2 基本功能

进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等。

内存管理：内存分配、地址映射、内存保护与共享、虚拟内存等。

文件管理：文件存储空间的管理、目录管理、文件读写管理和保护等。

设备管理：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

# 二、进程管理

## 2.1 进程与线程

### 2.1.1 进程

进程是资源分配的基本单位

进程控制块 (Process Control Block, PCB) 描述进程的**基本信息和运行状态**，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

### 2.1.2 线程

线程是独立调度的基本单位

一个进程种可以有多个线程，共享进程资源

### 2.1.3 区别

- 拥有资源

线程不拥有资源，进程是分配资源的基本单位

- 调度

线程是独立调度的基本单位，进程内线程切换不会引起进程切换

- 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

- 通信

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 2.2 进程状态的切换

![](http://mycsdnblog.work/201919072041-4.png)

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

## 2.3 进程调度算法

批处理系统：

- 先来先服务
- 短作业优先
- 最短剩余时间优先

交互式系统：

- 时间片轮转
- 优先级调度
- 多级反馈队列

## 2.4 进程同步

临界区：对资源互斥访问的代码区域

同步：多个进程按一定顺序执行

互斥：多个进程同一时刻只有一个可以进入临界区

信号量：PV操作

## 2.5 进程通信

首先，先来讲一下fork之后，发生了什么事情。

由fork创建的新进程被称为子进程（child process）。**该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0**，而**父进程的返回值则是新进程（子进程）的进程 id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id**。对子进程来说，之所以fork返回0给它，是因为它随时可以调用**getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id**。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。

fork之后，**操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置**（**两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的**），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。
可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。这也是fork为什么叫fork的原因

至于那一个最先运行，可能与操作系统（调度算法）有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。

进程通信的方式：

1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
7. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

- 管道：速度慢，容量有限
- 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
- 信号量：不能传递复杂消息，只能用来同步
- 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 2.5.1 管道

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程中使用。

## 2.6 线程通信

1.锁机制：包括互斥锁、条件变量、读写锁 
互斥锁提供了以排他方式防止数据结构被并发修改的方法。 
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 
条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

2.信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

3.信号机制(Signal)：类似进程间的信号处理 

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

# 三、死锁

## 3.1 必要条件

1.互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放 

2.请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。 

3.不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用 

4.循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。

# 四、内存管理

## 4.1 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

### 4.1.1 最佳

所选择的被换出的页面将是**最长时间内不再被访问**，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

![](http://mycsdnblog.work/201919152233-h.png)

开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。

### 4.1.2 最近最久未使用

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。

为了实现 LRU，需要在内存中维护一个所有**页面的链表。** **当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。**

因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

![](http://mycsdnblog.work/201919152235-J.png)

### 4.1.3 最近未使用

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

### 4.1.4 先进先出

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

# 六、面试

## 6.1 一个二进制文件怎么执行