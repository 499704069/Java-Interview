# 一、悲观锁

总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。

# 二、乐观锁

总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。

version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

核心SQL语句

update table set x=x+1, version=version+1 where id=#{id} and version=#{version};    

CAS操作方式：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。

# 三、重入锁

ReentrantLock(轻量级)等等 ) 。这些已经写好提供的锁为我们开发提供了便利。

重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。
在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁

# 四、读写锁

## 4.1 原理

## 4.2 使用

​	static ReentrantReadWriteLock *rwl* = new ReentrantReadWriteLock();

​	static Lock *r* = *rwl*.readLock();

​	static Lock *w* = *rwl*.writeLock();

```java
package com.thread.readwritelock;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @Author: 98050
 * @Time: 2019-04-29 20:53
 * @Feature:
 */
public class Cache {
    static Map<String,Object> map = new HashMap<String, Object>();
    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    static Lock r = rwl.readLock();
    static Lock w = rwl.writeLock();

    public static final Object get(String key){
        r.lock();
        try{
            System.out.println("正在读操作，key：" + key + "开始");
            Thread.sleep(100);
            Object o = map.get(key);
            System.out.println("读操作，key：" + key + "结束");
            return o;
        }catch (Exception e){

        }finally {
            r.unlock();
        }
        return null;
    }

    public static final Object put(String key,Object value){
        w.lock();
        try {
            System.out.println("正在做写操作，key：" + key + ",value" + value + "开始");
            Thread.sleep(100);
            Object o = map.put(key, value);
            System.out.println("写操作，key：" + key + ",value" + value + "结束");
            return o;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            w.unlock();
        }
        return null;
    }

    public static void main(String[] args) {
        new Thread(new Runnable(){

            public void run() {
                for (int i = 0; i < 10; i++) {
                    Cache.put(i+"", i);
                }
            }
        }).start();

        new Thread(new Runnable(){

            public void run() {
                for (int i = 0; i < 10; i++) {
                    Cache.get(i+"");
                }
            }
        }).start();
    }
}
```

运行结果：

```java
正在做写操作，key：0,value0开始
写操作，key：0,value0结束
正在读操作，key：0开始
读操作，key：0结束
正在做写操作，key：1,value1开始
写操作，key：1,value1结束
正在读操作，key：1开始
读操作，key：1结束
正在做写操作，key：2,value2开始
写操作，key：2,value2结束
正在做写操作，key：3,value3开始
写操作，key：3,value3结束
正在做写操作，key：4,value4开始
写操作，key：4,value4结束
正在做写操作，key：5,value5开始
写操作，key：5,value5结束
正在做写操作，key：6,value6开始
写操作，key：6,value6结束
正在做写操作，key：7,value7开始
写操作，key：7,value7结束
正在做写操作，key：8,value8开始
写操作，key：8,value8结束
正在做写操作，key：9,value9开始
写操作，key：9,value9结束
正在读操作，key：2开始
读操作，key：2结束
正在读操作，key：3开始
读操作，key：3结束
正在读操作，key：4开始
读操作，key：4结束
正在读操作，key：5开始
读操作，key：5结束
正在读操作，key：6开始
读操作，key：6结束
正在读操作，key：7开始
读操作，key：7结束
正在读操作，key：8开始
读操作，key：8结束
正在读操作，key：9开始
读操作，key：9结束
```

# 六、自旋锁

## 6.1 自旋锁

所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。**锁在原地循环的时候，是会消耗cpu的，就相当于在执行一个啥也没有的for循环。**

**本来一个线程把锁释放之后，当前线程是能够获得锁的，但是假如这个时候有好几个线程都在竞争这个锁的话，那么有可能当前线程会获取不到锁，还得原地等待继续空循环消耗cup，甚至有可能一直获取不到锁。**

**基于这个问题，我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。**

所以自旋等待的时间必须有一定的限度，超过了限定的次数仍然没有成功获取锁，就应当使用传统的方式挂起线程了。**自旋次数的默认值是10**，用户可以通过-XX:PreBlockSpin来更改。

## 6.2 自适应自旋

所谓自适应自旋锁就是线程空循环等待的**自旋次数并非是固定的**，而是会动态着根据实际情况来改变自旋等待的次数

自适应自旋锁的自适应反映在自旋的时间不在固定了。如果在同一个锁对象上，自旋线程之前刚刚获得过锁，且现在持有锁的线程正在运行中，那么虚拟机会认为这次自旋也很有可能会成功，进而允许该线程等待持续相对更长的时间，比如100个循环。反之，如果某个锁自旋很少获得过成功，那么之后再获取锁的时候将可能省略掉自旋过程，以避免浪费处理器资源。

# 七、CAS无锁机制

它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。

如何解决ABA的问题：版本号

# 八、AQS

AbstractQueuedSynchronizer ： 抽象队列同步器

AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。

AQS对象内部有一个核心变量叫做state，是int类型，代表了加锁的状态，初始值为0。

另一个核心变量就是用来记录当前加锁的是哪个线程，初始值为null



ReentrantLock和AQS之间的关系。

![](http://mycsdnblog.work/201919111651-j.png)

## 8.1 ReentrantLock加锁和释放锁的底层原理

好了，那么现在如果有一个线程过来尝试用ReentrantLock的lock()方法进行加锁，会发生什么事情呢？

很简单，这个AQS对象内部有一个核心的变量叫做**state**，是int类型的，代表了**加锁的状态**。初始状态下，这个state的值是0。

另外，这个AQS内部还有一个**关键变量**，用来记录**当前加锁的是哪个线程**，初始化状态下，这个变量是null。

![](http://mycsdnblog.work/201919111651-v.png)

接着线程1跑过来调用ReentrantLock的lock()方法尝试进行加锁，这个加锁的过程，直接就是用CAS操作将state值从0变为1。

如果之前没人加过锁，那么state的值肯定是0，此时线程1就可以加锁成功。

一旦线程1加锁成功了之后，就可以设置当前加锁线程是自己。所以大家看下面的图，就是线程1跑过来加锁的一个过程。

![](http://mycsdnblog.work/201919111652-9.png)

其实每次线程1可重入加锁一次，会判断一下当前加锁线程就是自己，那么他自己就可以可重入多次加锁，每次加锁就是把state的值给累加1，别的没啥变化。

接着，如果线程1加锁了之后，线程2跑过来加锁会怎么样呢？

**我们来看看锁的互斥是如何实现的？**线程2跑过来一下看到，哎呀！state的值不是0啊？所以CAS操作将state从0变为1的过程会失败，因为state的值当前为1，说明已经有人加锁了！

接着线程2会看一下，是不是自己之前加的锁啊？当然不是了，**“加锁线程”**这个变量明确记录了是线程1占用了这个锁，所以线程2此时就是加锁失败。

给大家来一张图，一起来感受一下这个过程：

![](http://mycsdnblog.work/201919111653-K.png)

接着，线程2会将自己放入AQS中的一个等待队列，因为自己尝试加锁失败了，此时就要将自己放入队列中来等待，等待线程1释放锁之后，自己就可以重新尝试加锁了

所以大家可以看到，AQS是如此的核心！AQS内部还有一个等待队列，专门放那些加锁失败的线程！

同样，给大家来一张图，一起感受一下：

![](http://mycsdnblog.work/201919111654-t.png)

接着，线程1在执行完自己的业务逻辑代码之后，就会释放锁！**他释放锁的过程非常的简单**，就是将AQS内的state变量的值递减1，如果state值为0，则彻底释放锁，会将“加锁线程”变量也设置为null！

![](http://mycsdnblog.work/201919111655-Y.png)

接下来，会从**等待队列的队头唤醒线程2重新尝试加锁。**

好！线程2现在就重新尝试加锁，这时还是用CAS操作将state从0变为1，此时就会成功，成功之后代表加锁成功，就会将state设置为1。

此外，还要把**“加锁线程”**设置为线程2自己，同时线程2自己就从等待队列中出队了。

最后再来一张图，大家来看看这个过程。

![](http://mycsdnblog.work/201919111656-5.png)

## 8.2 总结

**AQS就是一个并发包的基础组件，用来实现各种锁，各种同步组件的。它包含了state变量、加锁线程、等待队列等并发中的核心组件。**

# 九、synchronized底层实现原理

## 9.1 底层原理

**同步代码块**

synchronized的对象锁，其指针指向的是一个monitor对象（由C++实现）的起始地址。每个对象实例都会有一个 monitor。其中monitor可以与对象一起创建、销毁；亦或者当线程试图获取对象锁时自动生成。

每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：

1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。

2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.

3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

![](http://mycsdnblog.work/201919151359-R.png)

**同步方法**

从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了**ACC_SYNCHRONIZED**标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。

![](http://mycsdnblog.work/201919151402-A.png)

## 9.2 synchronized方法

```java 
package com.thread.lock;

import java.util.ArrayList;

/**
 * @Author: 98050
 * @Time: 2019-04-29 19:56
 * @Feature:
 */
public class Test006 {

    public static void main(String[] args) {
        Common common = new Common();
        new Thread(() -> {
            common.insert(Thread.currentThread());
        }).start();

        new Thread(() -> {
            common.insert(Thread.currentThread());
        }).start();
    }

}

class Common{
    private ArrayList<Integer> list = new ArrayList<>();

    public synchronized void insert(Thread thread){
        for (int i = 0; i < 5; i++) {
            System.out.println(thread.getName() + "在插入数据：" + i);
            list.add(i);
        }
    }
}
```

运行结果：

![](http://mycsdnblog.work/201919292030-Z.png)

当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。

2）当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的，

```java
package com.thread.lock;

import java.util.ArrayList;

/**
 * @Author: 98050
 * @Time: 2019-04-29 19:56
 * @Feature:
 */
public class Test006 {

    public static void main(String[] args) {
        Common common = new Common();
        new Thread(() -> {
            common.insert(Thread.currentThread());
        }).start();

        new Thread(() -> {
            //common.insert(Thread.currentThread());
            common.insert2();
        }).start();
    }

}

class Common{
    private ArrayList<Integer> list = new ArrayList<>();

    public synchronized void insert(Thread thread){
        for (int i = 0; i < 5; i++) {
            System.out.println(thread.getName() + "在插入数据：" + i);
            list.add(i);
        }
    }

    public void insert2(){
        for (int i = 0; i < 5; i++) {
            System.out.println("插入数据：" + i);
            list.add(i);
        }
    }
}
```

运行结果：

![](http://mycsdnblog.work/201919292034-3.png)　　

3）如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。

```java
package com.thread.lock;

import java.util.ArrayList;

/**
 * @Author: 98050
 * @Time: 2019-04-29 19:56
 * @Feature:
 */
public class Test006 {

    public static void main(String[] args) {
        Common common = new Common();
        Common common2 = new Common();
        new Thread(() -> {
            common.insert(Thread.currentThread());
        }).start();

        new Thread(() -> {
            common2.insert(Thread.currentThread());
        }).start();
    }

}

class Common{
    private ArrayList<Integer> list = new ArrayList<>();

    public synchronized void insert(Thread thread){
        for (int i = 0; i < 5; i++) {
            System.out.println(thread.getName() + "在插入数据：" + i);
            list.add(i);
        }
    }

    public void insert2(){
        for (int i = 0; i < 5; i++) {
            System.out.println("插入数据：" + i);
            list.add(i);
        }
    }
}
```

运行结果：

![](http://mycsdnblog.work/201919292036-s.png)

## 9.3 同步代码块

```java
package com.thread.lock;

import java.util.ArrayList;

/**
 * @Author: 98050
 * @Time: 2019-04-29 19:56
 * @Feature:
 */
public class Test006 {

    public static void main(String[] args) {
        Common common = new Common();
        new Thread(() -> {
            common.insert(Thread.currentThread());
        }).start();

        new Thread(() -> {
            common.insert(Thread.currentThread());
        }).start();
    }

}

class Common{
    private ArrayList<Integer> list = new ArrayList<>();

    public void insert(Thread thread){
        synchronized (this) {
            for (int i = 0; i < 5; i++) {
                System.out.println(thread.getName() + "在插入数据：" + i);
                list.add(i);
            }
        }
    }
}
```

运行结果：

![](http://mycsdnblog.work/201919292039-F.png)

## 9.4 静态同步方法

```java
package com.thread.lock;

/**
 * @Author: 98050
 * @Time: 2019-04-29 19:56
 * @Feature:
 */
public class Test006 {

    public static void main(String[] args) {
        Common common = new Common();
        new Thread(new Runnable(){

            @Override
            public void run() {
                common.insert();
            }
        }).start();

        new Thread(new Runnable(){

            @Override
            public void run() {
                Common.insert2();
            }
        }).start();
    }

}

class Common{

    public synchronized void insert(){
        System.out.println("执行insert1");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("执行insert1完毕");
    }

    public static synchronized void insert2(){
        System.out.println("执行insert2");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("执行insert2完毕");
    }
}
```

运行结果：

![](http://mycsdnblog.work/201919292044-Q.png)

如果一个线程执行一个对象的非static synchronized方法，另外一个线程需要执行这个对象所属类的static synchronized方法，此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，所以不存在互斥现象。

------

**所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。**

**而所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！**

**而对于同步块，由于其锁是可以选择的，所以只有使用同一把锁的同步块之间才有着竞态条件**，这就得具体情况具体分析了，但这里有个需要注意的地方，同步块的锁是可以选择的，但是不是可以任意选择的！！！！这里必须要注意一个物理对象和一个引用对象的实例变量之间的区别！使用一个引用对象的实例变量作为锁并不是一个好的选择，因为同步块在执行过程中可能会改变它的值，其中就包括将其设置为null，而对一个null对象加锁会产生异常，并且对不同的对象加锁也违背了同步的初衷！这看起来是很清楚的，但是一个经常发生的错误就是选用了错误的锁对象，因此必须注意：**同步是基于实际对象而不是对象引用的！多个变量可以引用同一个对象，变量也可以改变其值从而指向其他的对象，因此，当选择一个对象锁时，我们要根据实际对象而不是其引用来考虑！作为一个原则，不要选择一个可能会在锁的作用域中改变值的实例变量作为锁对象！！！！**  

# 十、锁的膨胀

